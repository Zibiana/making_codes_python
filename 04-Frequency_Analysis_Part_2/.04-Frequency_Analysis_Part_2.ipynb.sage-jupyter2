{"backend_state":"ready","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_ipynb_save":1709919548231,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"15db34","input":"# Add code here to encrypt the message","pos":52,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"199f0a","input":"ord(\"e\")","pos":28,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"1b1089","input":"solve_affine_congruences(c1 = 4, c2 = 13, p1 = 4, p2 = 19, mod = 26)","pos":90,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"1f1e18","input":"def shift_decrypt_freq_test(ciphertext, ciphertext_letter_guess, plaintext_letter_guess = \"e\"):\n    # Do stuff here\n    return(plaintext)","pos":19,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"2b0abf","input":"ciphertext_example2 = affine_encrypt(plaintext_example2, key = 12, m = 11)\nciphertext_example2","pos":69,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"30c2ef","input":"ord(\"k\") - ord(\"e\")","pos":29,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"323569","input":"def solve_affine_congruences(c1, c2, p1, p2, mod = 26):\n    solution_list = []\n    m_list = generate_units(mod)\n    for k in range(0, mod):\n        for m in m_list:\n            # Check if c = m*p + k\n            # or, equivalently, c - m*p - k = 0\n            if (c1 - m*p1 - k) % mod == 0 and (c2 - m*p2 - k) % mod == 0 :\n                solution_list.append((k, m))\n    return(solution_list)","pos":88,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"3b09b9","input":"analyze_frequencies(ciphertext_example1, output_format = \"percent\", sort = True)","pos":13,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"440490","input":"# Add code here to perform a frequency analysis of plaintext_example2","pos":63,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"46c345","input":"# Add code here to conduct a frequency analysis on the text","pos":98,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"471e35","input":"affine_decrypt(ciphertext_example2, key = 12, m = 11)","pos":77,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"477236","input":"ord(\"K\".lower()) - ord(\"t\")","pos":47,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"4c9fa3","input":"def shift_decrypt_freq(ciphertext, ciphertext_letter_guess, plaintext_letter_guess = \"e\"):\n    key_guess = ord(ciphertext_letter_guess.lower()) - ord(plaintext_letter_guess.lower())\n    plaintext = affine_decrypt(ciphertext, key = key_guess)\n    print(\"key = \" + str(key_guess))\n    print(plaintext)","pos":35,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"4f857c","input":"# Add code here to apply the function affine_decrypt_freq to the ciphertext\n# with your guesses for two ciphertext letters and their two matching plaintext letters.\n# (Your guesses should be based on the results of the frequency analysis above.)","pos":99,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"504f44","input":"##### Import libraries #####\n\nimport string\nimport math\nimport matplotlib.pyplot as plt\n\n\n##### Helper functions #####\n\ndef convert_letter_to_number(letter):\n    # Define constant that will allow us to move the letter codes by 97\n    MOVE_NUMBER = 97\n    # Convert input to ASCII (97 to 122)\n    number_ascii = ord(letter)\n    # Move number to lie in the range 0 to 25\n    number = number_ascii - MOVE_NUMBER\n    return number\n\ndef convert_number_to_letter(number):\n    # Define constant that will allow us to move the letter codes by 97\n    MOVE_NUMBER = 97\n    # Move number to lie in the ASCII range 97 to 122\n    number_ascii = number + MOVE_NUMBER\n    # Convert number to letter\n    letter = chr(number_ascii)\n    return letter\n\ndef generate_units(n):\n    unit_list = []\n    for m in range(1, n):\n        if math.gcd(m, n) == 1:\n            unit_list.append(m)\n    return unit_list\n\n\n##### Affine encryption functions #####\n\ndef affine_encrypt_letter(plaintext_letter, key, m = 1):\n    # Replace uppercase with lowercase\n    plaintext_letter = plaintext_letter.lower()\n    # Check if plaintext_letter is a lowercase letter\n    if ord(plaintext_letter) >= 97 and ord(plaintext_letter) <= 122:\n        plaintext_number = convert_letter_to_number(plaintext_letter)\n        ciphertext_number = (m* plaintext_number + key) % 26\n        ciphertext_letter = convert_number_to_letter(ciphertext_number)\n        return ciphertext_letter.upper()\n    else:\n        # If we get to this spot, we know we don't have a letter at all,\n        # so just return the character as is\n        return plaintext_letter\n\ndef affine_encrypt(plaintext, key, m = 1):\n    # Stop if m is not chosen appropriately\n    if math.gcd(m, 26) != 1:\n        print(\"The value of m must be relatively prime to 26!\")\n    else:\n        ciphertext = \"\"\n        for letter in plaintext:\n            ciphertext_letter = affine_encrypt_letter(letter, key, m)\n            ciphertext = ciphertext + ciphertext_letter\n        return ciphertext\n\ndef affine_decrypt(ciphertext, key, m = 1):\n    # Stop if m is not chosen appropriately\n    if math.gcd(m, 26) != 1:\n        print(\"The value of m must be relatively prime to 26!\")\n    else:\n        m_inv = pow(m, -1, mod = 26)\n        plaintext = affine_encrypt(ciphertext, -m_inv*key, m_inv)\n        return plaintext.lower()\n\n\n##### Frequency analysis functions #####\n\ndef freq_bar(letter_frequencies):\n    plt.bar(*zip(*letter_frequencies.items()))\n    plt.show()\n\ndef analyze_frequencies(text, output_format = \"count\", sort = False):\n    # Store uppercase alphabet\n    alph_upper = string.ascii_uppercase\n    # Convert text to uppercase\n    text = text.upper()\n    # Initialize frequencies to 0\n    frequencies = {}\n    for letter in alph_upper:\n        frequencies[letter] = 0\n    # Go through the text and for each letter,\n    # add 1 to the value corresponding to that letter\n    for letter in text:\n        if letter in alph_upper:\n            frequencies[letter] += 1\n    # Check output_format argument\n    if output_format not in [\"count\", \"percent\"]:\n        print('The output format must be either \"count\" or \"percent\".')\n        return\n    elif output_format == \"percent\":\n        total_letters = sum(frequencies.values())\n        for letter in frequencies:\n            frequencies[letter] = round(100 * frequencies[letter]/total_letters, ndigits = 3)\n    # Check sort argument\n    if sort:\n        frequencies = dict(sorted(frequencies.items(), key = lambda item: item[1], reverse = True))\n    print(frequencies)\n    # Create bar graph\n    freq_bar(frequencies)\n\n\n##### English letter frequencies (alphebtic and sorted by frequency) #####\n\nENGLISH_LETTER_FREQ = {\n    \"A\": 8.167, \"B\": 1.492, \"C\": 2.782, \"D\": 4.253, \"E\": 12.702, \"F\": 2.228, \"G\": 2.015, \"H\": 6.094, \"I\": 6.966, \"J\": 0.153, \"K\": 0.772, \"L\": 4.025, \"M\": 2.406, \"N\": 6.749, \"O\": 7.507, \"P\": 1.929, \"Q\": 0.095, \"R\": 5.987, \"S\": 6.327, \"T\": 9.056, \"U\": 2.758, \"V\": 0.978, \"W\": 2.360, \"X\": 0.150, \"Y\": 1.974, \"Z\": 0.074\n}\n\nENGLISH_LETTER_FREQ_SORT = dict(sorted(ENGLISH_LETTER_FREQ.items(), key = lambda item: item[1], reverse = True))","pos":4,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"53c98d","input":"affine_decrypt_freq(ciphertext_example2, \"E\", \"M\", \"e\", \"a\")","pos":96,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"5abbd5","input":"ciphertext_example2 = affine_encrypt(plaintext_example2, key = 12, m = 11)\nciphertext_example2","pos":66,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"5cf654","input":"shift_decrypt_freq(ciphertext_example1, \"K\")","pos":41,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"71158c","input":"# Add code here to conduct a frequency analysis on the text","pos":101,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"75d7fd","input":"ciphertext_example1","pos":37,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"7d182e","input":"plaintext_example2 = \"\"\"For instance, on the planet Earth, man had always assumed that he was more intelligent than dolphins because he had achieved so much—the wheel, New York, wars and so on—whilst all the dolphins had ever done was muck about in the water having a good time. But conversely, the dolphins had always believed that they were far more intelligent than man—for precisely the same reasons.” ― Douglas Adams, The Hitchhiker's Guide to the Galaxy\"\"\"","pos":68,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"8015e1","input":"# Add code here to perform a frequency analysis of the ciphertext","pos":54,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"892579","input":"analyze_frequencies(ciphertext_example2, output_format = \"percent\", sort = True)","pos":79,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"9274aa","input":"# Add code here to apply the function shift_decrypt_freq to the ciphertext\n# with your guess for the ciphertext letter and its matching plaintext letter.\n# (Your guess should be based on the results of the frequency analysis above.)","pos":55,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"a24aba","input":"# Add code here to try again","pos":44,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"b13215","input":"ord(\"k\")","pos":27,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"b3bc0c","input":"def affine_decrypt_freq(ciphertext, ciphertext_letter1_guess, ciphertext_letter2_guess, \\\n                        plaintext_letter1_guess = \"e\", plaintext_letter2_guess = \"t\"):\n    # Convert letters to numbers\n    p1_guess = convert_letter_to_number(plaintext_letter1_guess.lower())\n    c1_guess = convert_letter_to_number(ciphertext_letter1_guess.lower())\n    p2_guess = convert_letter_to_number(plaintext_letter2_guess.lower())\n    c2_guess = convert_letter_to_number(ciphertext_letter2_guess.lower())\n    # Solve system of linear congruences\n    solution_list = solve_affine_congruences(c1_guess, c2_guess, p1_guess, p2_guess, mod = 26)\n    if solution_list:\n        for solution_pair in solution_list:\n            print(\"(k, m) = \" + str(solution_pair))\n            print(affine_decrypt(ciphertext, key = solution_pair[0], m = solution_pair[1]))\n    else:\n        print(\"No solution\")","pos":92,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"b52199","input":"plaintext_example2 = \"\"\"\nFor instance, on the planet Earth, man had always assumed that he was more intelligent than dolphins because he had achieved so much—the wheel, New York, wars and so on—whilst all the dolphins had ever done was muck about in the water having a good time. But conversely, the dolphins had always believed that they were far more intelligent than man—for precisely the same reasons.”\n― Douglas Adams, The Hitchhiker's Guide to the Galaxy\n\"\"\"","pos":61,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"b91ba5","input":"# Add code here to test the shift_decrypt_freq function with a non-letter character guess","pos":58,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"d71b1c","input":"affine_decrypt_freq(ciphertext_example2, \"E\", \"M\")","pos":94,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"dc0b24","input":"ciphertext_example1 = \"KYZJKVOKZJRCZKKCVLELJLRCZEKYRKKZJRTKLRCCPKYVDFJKTFDDFECVKKVI\"","pos":6,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"e10b0d","input":"# Add code here to apply the function affine_decrypt_freq to the ciphertext\n# with your guesses for two ciphertext letters and their two matching plaintext letters.\n# (Your guesses should be based on the results of the frequency analysis above.)","pos":102,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"edb146","input":"# Add code here to subtract ASCII codes","pos":31,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"eec646","input":"shift_decrypt_freq(ciphertext_example1, \"K\", \"e\")","pos":39,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"f1eaa9","input":"# Add code here to make a bar chart","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"05a6a3","input":"The letter \"K\" is the most frequent letter by far. We will guess that this is the plaintext letter \"e\".","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"076846","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":51,"type":"cell"}
{"cell_type":"markdown","id":"084422","input":"### Exercise 5\n\nCopy the subtraction code above and paste in in the code cell below, but use an uppercase \"K\" instead. Even though the ciphertext is \"K\", why would it be a bad idea to use an uppercase \"K\" in the code?","pos":30,"type":"cell"}
{"cell_type":"markdown","id":"095a9d","input":"Why is this not a problem for the algorithm?","pos":48,"type":"cell"}
{"cell_type":"markdown","id":"0a71f5","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":49,"type":"cell"}
{"cell_type":"markdown","id":"119d28","input":"## Your name goes here. \\(Double\\-click on this cell to edit it.\\)\n\nRemember to hit Ctrl-Enter after editing any cell.\n\n","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"16d41e","input":"### Exercise 11\n\nPerform a frequency analysis of the text. You should find out that the most common letters are \"e\" followed by \"a\".","pos":62,"type":"cell"}
{"cell_type":"markdown","id":"1c15b7","input":"*****","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"1e3faf","input":"*****","pos":33,"type":"cell"}
{"cell_type":"markdown","id":"1f5824","input":"*****","pos":64,"type":"cell"}
{"cell_type":"markdown","id":"25aeeb","input":"## Conclusion","pos":103,"type":"cell"}
{"cell_type":"markdown","id":"267e4e","input":"### Exercise 17\n\nDecrypt the following ciphertext using frequency analysis:\n\nQV UKE VZA BAEV OR VQGAE, QV UKE VZA UONEV OR VQGAE, QV UKE VZA KIA OR UQEJOG, QV UKE VZA KIA OR ROOPQEZXAEE, QV UKE VZA AFOSZ OR BAPQAR, QV UKE VZA AFOSZ OR QXSNAJMPQVC, QV UKE VZA EAKEOX OR PQIZV, QV UKE VZA EAKEOX OR JKNYXAEE, QV UKE VZA EFNQXI OR ZOFA, QV UKE VZA UQXVAN OR JAEFKQN, UA ZKJ ADANCVZQXI BARONA ME, UA ZKJ XOVZQXI BARONA ME, UA UANA KPP IOQXI JQNASV VO ZAKDAX, UA UANA KPP IOQXI JQNASV VZA OVZAN UKC – QX EZONV, VZA FANQOJ UKE EO RKN PQYA VZA FNAEAXV FANQOJ, VZKV EOGA OR QVE XOQEQAEV KMVZONQVQAE QXEQEVAJ OX QVE BAQXI NASAQDAJ, RON IOOJ ON RON ADQP, QX VZA EMFANPKVQDA JAINAA OR SOGFKNQEOX OXPC.\n","pos":97,"type":"cell"}
{"cell_type":"markdown","id":"29ba78","input":"Everything in the above function should be clear with two exceptions:\n\n1. In the function signature, there is a backslash \\ at the end of the line. All this is doing is allowing us to keep writing the code on a new line without giving us an error. The function is just easier to read if we can let the parameters spill onto another line. By the way, the default arguments for the plaintext guesses are \"e\" and \"t\" because these are the two most common letters in English text.\n2. The line\n\n```\nif solution_list:\n```\n\nseems incomplete. If the solution list is what? This is simply checking that the solution list is not empty. If there are solutions, then `solution_list` will be `True` in this if statement. If the solution list is empty, `solution_list` will be `False` and we will go down to the `else` clause.\n\nWe now test the new function. Here is our earlier incorrect guess. (Remember that in the function signature, the plaintext guesses are, by default, \"e\" and \"t\".)","pos":93,"type":"cell"}
{"cell_type":"markdown","id":"2b9ed2","input":"Surprisingly, we only need two lines of code to execute the basic idea:\n\n1. Calculate the key from the guesses.\n2. Decrypt the message using the key.\n\nHere is the whole function:","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"2d236a","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"335400","input":"## Objectives\n\nIn this activity we will use Python to conduct a frequency analysis of ciphertext. We'll see how a frequency analysis can help us decrypt shift ciphers and affine ciphers.","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"3e5110","input":"### Exercise 3\n\nIn your own words, describe the steps you would use to implement the algorithm. You don't need to write any code. Just explain what the algorithm will need to do with the inputs `ciphertext_letter_guess` and `plaintext_letter_guess` and how that will lead to a complete decryption of the message in the final line. Be as specific as you can. Keep in mind that we already have a function `affine_decrypt` that will produce the plaintext once the key is known. (We could use `shift_decrypt`, but remember that `affine_decrypt` is the same function as long as $m = 1$.)","pos":20,"type":"cell"}
{"cell_type":"markdown","id":"4b692e","input":"# Frequency Analysis, Part 2","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"515543","input":"We have a minor issue here. Newlines have been translated into the symbol \"\\n\". If we leave these newlines in our text string, it will screw up our frequency analysis (inflating the number of \"n\"s present.) To remove these, we will re-save our plaintext without the newlines.","pos":67,"type":"cell"}
{"cell_type":"markdown","id":"54eae8","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":59,"type":"cell"}
{"cell_type":"markdown","id":"5677dc","input":"To tell the computer to do what you explained in words for the exercise above, we need to represent the letters as numbers. ASCII to the rescue:","pos":26,"type":"cell"}
{"cell_type":"markdown","id":"5706ae","input":"### Exercise 4\n\nLet's find the key based on our guess. In our example, we suspect that the ciphertext letter \"K\" may correspond to the plaintext letter \"e\". If that is true, what shift key was used. Explain in words how you calculated it.","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"5ae8b8","input":"*****","pos":22,"type":"cell"}
{"cell_type":"markdown","id":"5c6078","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"668903","input":"### Exercise 9\n\nLet's go through all this again with a new example. Here is the ciphertext:\n\n\"BRX DUH WKH VXP WRWDO RI HYHUBWKLQJ BRX'YH HYHU VHHQ, KHDUG, HDWHQ, VPHOOHG, EHHQ WROG, IRUJRW - LW'V DOO WKHUH. HYHUBWKLQJ LQIOXHQFHV HDFK RI XV, DQG EHFDXVH RI WKDW L WUB WR PDNH VXUH WKDW PB HASHULHQFHV DUH SRVLWLYH.\" -PDBD DQJHORX\n\nUse frequency analysis to decrypt the message. When you're finished, type up the plaintext using correct capitalization.\n\n(Be careful. If you're getting errors, check the quotation marks!)","pos":53,"type":"cell"}
{"cell_type":"markdown","id":"66d92a","input":"## Preliminaries\n\nIn this section, we'll import any libraries we need and load the functions we've developed in past modules. Actually, we can tidy things up a little by noting that shift encryption is just a special case of affine encryption where $m = 1$. (I've changed the code below so that $m = 1$ is the default value of $m$. If we want shift encryption, that allows us to leave out the argument for $m$ altogether if we want.) So we really only have to load functions for affine encryption/decryption and frequency analysis.\n\nTo make it easier to run, I've put all the code in one big code cell. That's not a generally recommended practice, but it means you can just click inside the cell below and run it using Ctrl-Enter. (Throughout the module, you will need to remember to click on code cells and hit Ctrl-Enter.)","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"69750e","input":"Since \"e\" is the default plaintext guess, we could also simply type this:","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"6a985b","input":"*****","pos":75,"type":"cell"}
{"cell_type":"markdown","id":"6c40e2","input":"The correct guess:","pos":95,"type":"cell"}
{"cell_type":"markdown","id":"6cf8b6","input":"And we plug it into the function:","pos":38,"type":"cell"}
{"cell_type":"markdown","id":"6d7472","input":"*Please write up your answer here.*","pos":56,"type":"cell"}
{"cell_type":"markdown","id":"6ecf42","input":"## Frequency analysis of shift ciphers\n\nRecall that with a shift cipher, once we know a single letter, we have the key. Therefore, we need to write a function that will allow us to guess a letter (based on a frequency analysis) and use that guess to try to decrypt the ciphertext. Here is the ciphertext we we use:","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"6fbc41","input":"*****","pos":25,"type":"cell"}
{"cell_type":"markdown","id":"72499a","input":"(When you're looking at the output, you have to remember that the value of $k$ comes first, followed by the value of $m$.)\n\nWe're now ready to define our function for solving affine ciphers using frequency analysis. We'll use our helper functions `convert_letter_to number` and `convert_number_to_letter`, but don't forget that those functions only work for lowercase letters. Here is the grand finale:","pos":91,"type":"cell"}
{"cell_type":"markdown","id":"741258","input":"### Exercise 8\n\nWhat is the correct key for this example, expressed as a number reduced modulo 26? (In other words, -9 is not the answer here, but it's related to the answer.) Check that you are correct by encrypting the plaintext using `affine_encrypt` with the correct key (and with $m = 1$) to recover the ciphertext you started with.","pos":50,"type":"cell"}
{"cell_type":"markdown","id":"786add","input":"The first thing to do when analyzing a ciphertext is to conduct a frequency analysis. We will use the `analyze_frequencies` function:","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"7bd51c","input":"### Exercise 15\n\nIf you did the exercise above correctly, you should have obtained $k = 14$ and $m = 4$. Normally, you would use those values to try to decrypt the ciphertext using the code\n\n```\naffine_decrypt(ciphertext_example2, key = 14, m = 4)\n```\n\nHowever, in this case, you can be sure that you have an incorrect $k$ and $m$ before even trying to decrypt the ciphertext. Why? (Hint: do you see anything wrong with the value $m = 4$?)","pos":83,"type":"cell"}
{"cell_type":"markdown","id":"7e8979","input":"As a reminder, here is the ciphertext we're trying to decrypt:","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"835ce3","input":"*****","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"844f8b","input":"Without spacing or punctuation, we have very few hints here.\n\nOf course, with shift ciphers, there are only 25 possible keys, so we could brute force this ciphertext and find the message by inspection. Nevertheless, we'll use frequency analysis to show how it works. In future examples where brute force is difficult or impossible, frequency analysis will be the only tool at our disposal.","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"8c3948","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":72,"type":"cell"}
{"cell_type":"markdown","id":"927236","input":"### Exercise 2\n\nIs the ciphertext letter \"K\" guaranteed to correspond to the plaintext letter \"e\"? What kinds of ciphertexts would give you more confidence in that assertion?","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"955b5c","input":"### Exercise 18\n\nDecrypt the following ciphertext using frequency analysis:\n\nJM JH V UVC, UVC APMMPC MEJIZ MEVM J KN, MEVI J EVWP PWPC KNIP; JM JH V UVC, UVC APMMPC CPHM J ZN MN MEVI J EVWP PWPC TINBI\n\n(Hint: if your first few guesses don't work, keep trying!)","pos":100,"type":"cell"}
{"cell_type":"markdown","id":"9a9d0d","input":"Now let's encrypt the message, using a key of 12 and $m = 11$. (Remember that $m$ has to be relatively prime to 26.)","pos":65,"type":"cell"}
{"cell_type":"markdown","id":"9e2e35","input":"*Please write up your answer here.*","pos":82,"type":"cell"}
{"cell_type":"markdown","id":"a0d632","input":"## Math topics used in this module\n\n*","pos":1.75,"type":"cell"}
{"cell_type":"markdown","id":"a1833b","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":86,"type":"cell"}
{"cell_type":"markdown","id":"a2a1c3","input":"### Exercise 6\n\nClearly, we guessed wrong. Let's assume \"K\" represents the second-most common English letter. Make the necessary change to the function arguments and try again. If successful, write the plaintext out using proper spacing.","pos":43,"type":"cell"}
{"cell_type":"markdown","id":"a94a08","input":"### Exercise 14\n\nFind the letter value of \"M\". (Not the ASCII value, but the value between 0 and 25.) Set up the system of linear congruences this implies. The first linear congruence---the one for \"E\" and \"e\"---will be the same as before, but the second one has one number that will change. In other words, the new system will look like\n\n$$\n4m + k \\equiv 4 \\mod 26\n$$\n$$\n19m + k \\equiv ? \\mod 26\n$$\n\nBut you need to fill in the question mark and then solve this system by hand. (Again, just report the answer you get for $k$ and $m$.)","pos":81,"type":"cell"}
{"cell_type":"markdown","id":"abb4e6","input":"### Exercise 13\n\nUsing math, explain why the plaintext \"e\" became the ciphertext \"E\".","pos":73,"type":"cell"}
{"cell_type":"markdown","id":"bb71bd","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":84,"type":"cell"}
{"cell_type":"markdown","id":"bce2fa","input":"For example, the earlier system of linear congruences\n\n$$\n4 \\equiv 4m + k \\mod 26\n$$\n\n$$\n13 \\equiv 19m + k \\mod 26\n$$\n\nwould be entered into the function as follows:","pos":89,"type":"cell"}
{"cell_type":"markdown","id":"bf60c8","input":"Uh oh, that doesn't look like recognizable plaintext.","pos":42,"type":"cell"}
{"cell_type":"markdown","id":"bfe127","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"c2111d","input":"## Frequency analysis of affine ciphers\n\nThe function for affine ciphers is going to be a little more challenging. While we can use frequency analysis to identify the most common letters, we need to figure out both the key and the value of $m$. First of all, since we have two unknowns, it won't be enough to guess one letter anymore. We'll need two. Furthermore, even with those two letters, it's not immediately obvious how to translate those guesses into a determination of the key and the value of $m$.\n\nHere is some plaintext:\n\n> \"For instance, on the planet Earth, man had always assumed that he was more intelligent than dolphins because he had achieved so much—the wheel, New York, wars and so on—whilst all the dolphins had ever done was muck about in the water having a good time. But conversely, the dolphins had always believed that they were far more intelligent than man—for precisely the same reasons.”\n― Douglas Adams, The Hitchhiker's Guide to the Galaxy\n\nDue to the presence of both apostrophes and double quotes, we will use triple quotes to store this text:","pos":60,"type":"cell"}
{"cell_type":"markdown","id":"c4ba98","input":"### Exercise 10\n\nUsually, we add more code to make our function robust against user error. In this case, though, we did not do that. Why not? In other words, will the function result in an error if a character other than a letter is passed to either of the latter two arguments? Try it and then explain why the function still works (even if it gives a nonsensical output).","pos":57,"type":"cell"}
{"cell_type":"markdown","id":"c71950","input":"### Exercise 7\n\nNotice that the code for `shift_decrypt_freq` does not reduce anything mod 26. In fact, the second line of code will produce the following in our example:","pos":46,"type":"cell"}
{"cell_type":"markdown","id":"c98d31","input":"The question is, what do we do if we don't know $k$ and $m$?\n\nThis is where frequency analysis comes into play. Here are the frequencies of letters in the ciphertext:","pos":78,"type":"cell"}
{"cell_type":"markdown","id":"ce67b8","input":"## Can we make the computer do the yucky part?\n\nEven though we can encrypt and decrypt affine ciphers with code, one hard part still remains: solving the system of linear congruences that results from a frequency analysis. If we happen to guess the two most frequent letters correctly, we only have to solve one system of congruences (and that's bad enough), but if we guess wrong, who knows how many other pairs of letters we may have to guess before hitting upon the correct ones.\n\nWe would like to automate this whole process, including the part about solving linear congruences. There are two ways we could proceed:\n\n1. We could try to go through all the steps of our procedure for solving systems of linear congruences, and then try to translate everything into code. This seems...hard.\n2. We could also acknowledge that computers are fast, and so maybe we can just try every possible value of $k$ and $m$ to get all possible solutions. There are only 25 possible values of $k$ and 12 possible values of $m$. That's only 300 values to test.\n\nWhile option (1) is certainty possible, it's not even clear if it would be more efficient. Certainly, the code would be much messier. We'll go with option (2).","pos":87,"type":"cell"}
{"cell_type":"markdown","id":"cfaafa","input":"The answer you obtained by hand should not have been a surprise. After all, we can go back and see the choices that we made: the key was 12 and $m$ was 11.\n\nNow, if we use `affine_decrypt` with the values of $k$ and $m$, we recover the plaintext:","pos":76,"type":"cell"}
{"cell_type":"markdown","id":"d09880","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":45,"type":"cell"}
{"cell_type":"markdown","id":"d302b8","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"d51e3f","input":"## Commands in python introduced in this module\n\n---\n>\n___","pos":1.5,"type":"cell"}
{"cell_type":"markdown","id":"d9da17","input":"We have now automated the majority of our encryption and decryption tasks. The result is a collection of functions that can be used in any cryptological situation that involves either a shift or affine cipher, or one that benefits from frequency analysis.\n\nAlong the way, we've learned a little bit about how Python code works. More importantly, we've learned how to think *algorithmically*; that is, we are hopefully getting better at solving complex problems by breaking them down into small, easy-to-execute steps.","pos":104,"type":"cell"}
{"cell_type":"markdown","id":"db7b8b","input":"### Exercise 16\n\nNow that we know we guessed incorrectly, we need another guess. Given the dominant prevalance of the \"E\" in the ciphertext, it seems likely that we got that one correct. It may be that our guess for \"M\" is wrong. (Secretly, we already know that to be the case.) So what is the third-most common letter in the English language? Perhaps the \"M\" corresponds to that letter?\n\nSet up a new system of linear congruences for this new guess and solve it for $k$ and $m$. This time, it will look like the following:\n\n$$\n4m + k \\equiv 4 \\mod 26\n$$\n$$\n?m + k \\equiv 12 \\mod 26\n$$\n\nBut you need to figure out what goes in place of the question mark (the number for the third-most common letter in English). **Careful**: there will be two solutions, but only one of them makes sense. The one that works will be the right answer this time.\n\nIn the space below, list both solutions you obtained and explain why only one of the solutions makes sense.","pos":85,"type":"cell"}
{"cell_type":"markdown","id":"dcaf83","input":"If we match up the ciphertext frequencies to the English language, we might guess that the ciphertext \"E\" (the most common ciphertext letter) is the plaintext letter \"e\" (the most common English letter) and that the ciphertext letter \"M\" (the second-most common ciphertext letter) is the plaintext letter \"t\" (the second-most common English letter). THIS TURNS OUT TO BE AN INCORRECT GUESS! But, of course, we don't know that when all we have is the frequency analysis of the ciphertext. We have no choice but to follow this lead, as it's our best guess.","pos":80,"type":"cell"}
{"cell_type":"markdown","id":"df97c5","input":"Here is a basic shell for the function we will develop:","pos":18,"type":"cell"}
{"cell_type":"markdown","id":"e1085c","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":74,"type":"cell"}
{"cell_type":"markdown","id":"e3b385","input":"### Exercise 12\n\nSolve the system of linear congruences above. In other words, find the values of $m$ and $k$. I've rewritten it below to look more like the form we've practiced:\n\n$$\n 4m + k \\equiv 4 \\mod 26\n$$\n$$\n19m + k \\equiv 13 \\mod 26\n$$\n\nAlso note that, in general, there might be multiple solutions, but in this case, there happens to be a unique solution.\n\nYou won't be able to type up all your work, so it's okay if you just report the answer you get.","pos":71,"type":"cell"}
{"cell_type":"markdown","id":"e63b55","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":24,"type":"cell"}
{"cell_type":"markdown","id":"eff72e","input":"### Exercise 1\n\nWhat is the most common letter in the English language? You probably know the answer to that question off the top of your head. What is the second-most common letter? You may be a little more uncertain about that one.\n\nUsing the dictionary `ENGLISH_LETTER_FREQ_SORT`, make a bar chart of the frequencies of English letters. Use the `freq_bar` function as defined above. Then write up your answer to the questions above.","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"f24b8e","input":"Let's look at the math for the affine cipher. Recall that we convert the plaintext to ciphertext using:\n\n$$\nc_i \\equiv m p_i + k \\mod 26\n$$\n\nLet's pretend that we don't know the values of $m$ and $k$. Instead, let's plug in some known plaintext letters with their corresponding ciphertext letters. For example, we can see that the plaintext letter \"e\" actually corresponds to \"E\" in the ciphertext. (This was just a lucky coincidence.) Since the letter \"e\" is 4 when using mod 26 (remember that \"a\" = 0), we can write the equation as\n\n$$\n4 \\equiv m(4) + k \\mod 26\n$$\n\nWhat about the letter \"t\" in the plaintext? This has been encoded as \"N\" in the ciphertext. \"t\" = 19 and \"N\" is 13:\n\n$$\n13 \\equiv m(19) + k \\mod 26\n$$\n\nThis gives us a system of two linear congruences, which we know how to solve.\n\n\n","pos":70,"type":"cell"}
{"id":0,"time":1709842749176,"type":"user"}
{"last_load":1707429833437,"type":"file"}