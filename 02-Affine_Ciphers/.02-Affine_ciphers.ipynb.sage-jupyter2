{"backend_state":"ready","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_ipynb_save":1709919554899,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"01c847","input":"math.gcd(153, 68)","pos":58,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"0757d3","input":"def affine_encrypt(plaintext, key, m):\n    # Stop if m is not chosen appropriately\n    if math.gcd(m, 26) != 1:\n        print(\"The value of m must be relatively prime to 26!\")\n    else:\n        ciphertext = \"\"\n        for letter in plaintext:\n            ciphertext_letter = affine_encrypt_letter(letter, key, m)\n            ciphertext = ciphertext + ciphertext_letter\n        return ciphertext","pos":60,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"0c1d8e","input":"pow(2, -1)","pos":20,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"28b7de","input":"affine_encrypt_test(\"Affine ciphers aren't so bad!\", key = 0, m = 2)","pos":48,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"2a0431","input":"import math","pos":56,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"2f6316","input":"def affine_decrypt(ciphertext, key, m):\n    # Stop if m is not chosen appropriately\n    if math.gcd(m, 26) != 1:\n        print(\"The value of m must be relatively prime to 26!\")\n    else:\n        m_inv = pow(m, -1, mod = 26)\n        plaintext = affine_encrypt(ciphertext, -m_inv*key, m_inv)\n        return plaintext.lower()","pos":66,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"333012","input":"def affine_encrypt_test(plaintext, key, m):\n    ciphertext = \"\"\n    for letter in plaintext:\n        ciphertext_letter = affine_encrypt_letter(letter, key, m)\n        ciphertext = ciphertext + ciphertext_letter\n    return ciphertext","pos":44,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"67ec2b","input":"# Add code here to encrypt a phrase using m = 13","pos":52,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"697119","input":"def affine_encrypt_letter(plaintext_letter, key, m):\n    # Replace uppercase with lowercase\n    plaintext_letter = plaintext_letter.lower()\n    # Check if plaintext_letter is a lowercase letter\n    if ord(plaintext_letter) >= 97 and ord(plaintext_letter) <= 122:\n        plaintext_number = convert_letter_to_number(plaintext_letter)\n        ciphertext_number = (m* plaintext_number + key) % 26\n        ciphertext_letter = convert_number_to_letter(ciphertext_number)\n        return ciphertext_letter.upper()\n    else:\n        # If we get to this spot, we know we don't have a letter at all,\n        # so just return the character as is\n        return plaintext_letter","pos":32,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"6fe487","input":"# Add code here to decrypt\n#   \"NS'B DJPW WHKGXK SL ONUG SWX CMHNUSXIS RWXU ZLJ WHAX SL BPKLMM SWKLJFW BL DHUZ CLBBNYNMNSNXB!\"","pos":83,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"71b192","input":"# Add code here to test generate_units for different values of n","pos":78,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"7dc01c","input":"# Add code here to test an illegal value of m","pos":64,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"8e9daa","input":"generate_units(26)","pos":76,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"9168c1","input":"affine_encrypt_letter(\"c\", key = 16, m = 3)","pos":37,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"a51963","input":"pow(6, 2, mod = 20)","pos":22,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"ac9559","input":"affine_encrypt_test(\"Affine ciphers aren't so bad!\", key = 21, m = 15)","pos":46,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"b1e1ed","input":"# Add code here to test the pow function when there is no inverse","pos":26,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"c45098","input":"pow(2, 4)","pos":18,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"c71123","input":"def brute_affine_decrypt(ciphertext):\n    # Get list of legal m values\n    m_list = generate_units(26)\n    for key in range(1, 26):\n        for m in m_list:\n            # You fill in the missing line here\n            print(\"Key = \" + str(key) + \", m = \" + str(m) + \": \" + plaintext)","pos":81,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"db8e54","input":"affine_decrypt(\"VSSLID ZLMWDQF VQDI'U FX KVO!\", key = 21, m = 15)","pos":68,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"e57999","input":"def generate_units(n):\n    unit_list = []\n    for m in range(1, n):\n        if math.gcd(m, n) == 1:\n            unit_list.append(m)\n    return unit_list","pos":75,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"e8d24a","input":"pow(3, -1, mod = 26)","pos":12,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"f88660","input":"def convert_letter_to_number(letter):\n    # Define constant that will allow us to move the letter codes by 97\n    MOVE_NUMBER = 97\n    # Convert input to ASCII (97 to 122)\n    number_ascii = ord(letter)\n    # Move number to lie in the range 0 to 25\n    number = number_ascii - MOVE_NUMBER\n    return number\n\ndef convert_number_to_letter(number):\n    # Define constant that will allow us to move the letter codes by 97\n    MOVE_NUMBER = 97\n    # Move number to lie in the ASCII range 97 to 122\n    number_ascii = number + MOVE_NUMBER\n    # Convert number to letter\n    letter = chr(number_ascii)\n    return letter","pos":30,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"fa9b0a","input":"# Add code here to check the function against your work by hand.","pos":41,"type":"cell"}
{"cell_type":"markdown","id":"0559be","input":"### Exercise 7\n\nIn fairness, we didn't really test the function above all that rigorously. The result of using the letter \"c\" with key 16 and $m = 3$ was not greater than 26, so we didn't really test that everything works mod 26. Try it again with the letter \"f\" using a key of 5 and $m = 11$. Figure out what the answer should be by hand. Then use the `affine_encrypt_letter` function to verify your work.","pos":39,"type":"cell"}
{"cell_type":"markdown","id":"059cea","input":"### Exercise 14\n\nIn the code cell below, we define a function called `brute_affine_decrypt`. Its goal is to try every possible key and every possible value of $m$ on the ciphertext and print the resulting plaintext. Notice that to do that, we have *nested* for loops. For every value of the key, we also cycle through every legal value of $m$.\n\nRemove the hashtag from the missing line and type the code that will make this function work. (Hint: you should use a function we already defined.)","pos":80,"type":"cell"}
{"cell_type":"markdown","id":"0a41d2","input":"## Commands in python introduced in this module\n\n---\n> pow, import math, math.gcd, !=\n___","pos":1.5,"type":"cell"}
{"cell_type":"markdown","id":"119d28","input":"## Your name goes here. \\(Double\\-click on this cell to edit it.\\)\n\nRemember to hit Ctrl-Enter after editing any cell.\n\n","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"15d0be","input":"### Exercise 2\n\nThe values of $m$ that have a multiplicative inverse mod 26 are those numbers between 1 and 25 that are relatively prime to 26. Two numbers are relatively prime if their GCD is 1. Make a list of all such values below:\n","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"1edcd0","input":"## Some math\n\nBefore discussing affine ciphers, let's return to the simple shift cipher, but introduce some mathematical notation  \n to describe what is happening.\n\nSuppose the letters of the alphabet are replaced with numbers so that \"a\" = 0 and \"z\" = 25. (Make sure you understand why \"z\" is 25 and not 26!)\n\nSuppose there are $n$ letters of plaintext that need to be encoded. We will call these letters $p_0, p_1, p_2,  \\dots, p_{n-1}$. For example, if the plaintext is \"mysecret\", then\n\n$$\np_0 = m \\\\\np_1 = y \\\\\np_2 = s \\\\\np_3 = e \\\\\np_4 = c \\\\\np_5 = r \\\\\np_6 = e \\\\\np_7 = t\n$$\n\nSuppose the key is a number $k$. Then the ciphertext characters $c_0, c_1, c_2, \\dots, c_{n-1}$ will be given by the following formula:\n\n$$\nc_i \\equiv p_i + k \\mod 26\n$$\n\n","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"1f408e","input":"### Exercise 8\n\nExamine the output above carefully. Can you spot the problem? (Hint: Because there is no shift, \"a\" = 0 will be encoded as \"A\" because 2 times 0 is still 0. But what if you were trying to decode the letter \"A\" in the rest of the ciphertext?)\n\nExplain using modular arithmetic why certain pairs of distinct plaintext letters get encoded as the same ciphertext letter.","pos":49,"type":"cell"}
{"cell_type":"markdown","id":"28b1be","input":"**VERY IMPORTANT!** Since the last command should have resulted in an error, if we leave it alone, it may prevent future cells from running if we ever go back and run all the cells from the beginning of the document. Once you have verified that you get the appropriate error, go back into the code cell and put a hashtag at the beginning of the line with the pow function. This will tell Python to ignore this code on future passes.","pos":28,"type":"cell"}
{"cell_type":"markdown","id":"29616b","input":"## Math topics used in this module\n\n* Modular arithmetic\n* inverses mod $n$\n* linear congruences\n* Solving systems of equations\n* Exponents","pos":1.625,"type":"cell"}
{"cell_type":"markdown","id":"2f3937","input":"### Making our function more robust\n\nAs we saw above, there are issues with using a value of $m$ that is not relatively prime to 26. We can build into our function a test that forces the user to choose a suitable value of $m$.\n\nTo do this, we need a way of checking that $m$ and 26 are relatively prime. In other words, we need to check that the greatest common divisor (gcd) of $m$ and 26 is 1.\n\nWhile there is no `gcd` function built into basic Python, there is a library called `math` that contains a `gcd` function.\n\nTo use functions from an external library, we need the following line of code:","pos":55,"type":"cell"}
{"cell_type":"markdown","id":"30dce1","input":"Conveniently, Python has a function that allows us to compute inverses. It's called `pow`. For example, suppose we want to find the inverse of 3 mod 26. (Click in the cell below and hit Ctrl-Enter to run it. You will be expected to remember to run all code cells that follow.)","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"326d89","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"335400","input":"## Objectives\n\nIn this activity we will use Python to encrypt and decrypt affine ciphers.\n\n","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"34a084","input":"*****","pos":42,"type":"cell"}
{"cell_type":"markdown","id":"37a82e","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"3fb46a","input":"*****","pos":73,"type":"cell"}
{"cell_type":"markdown","id":"43e536","input":"Here is the new and improved affine encryption function:","pos":59,"type":"cell"}
{"cell_type":"markdown","id":"4b578e","input":"### Exercise 4\n\nExplain why the answer was 16 in the example above.","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"4b692e","input":"# Affine ciphers","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"532e18","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":53,"type":"cell"}
{"cell_type":"markdown","id":"5803aa","input":"## Brute force decryption\n\nIf we are the desired recipient of an encrypted message, the idea is that we know the key used to encrypt it as well as the correct value of $m$. We can then use the function `affine_decrypt` from above to decipher the message sent to us.\n\nHowever, suppose we intercept an encrypted message. We do not know the key or the value of $m$. So how might we go about deciphering the message?","pos":70,"type":"cell"}
{"cell_type":"markdown","id":"628576","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":24,"type":"cell"}
{"cell_type":"markdown","id":"63e829","input":"### Exercise 13\n\nTest the `generate_units` function for a whole bunch of different values for $n$.\n\nFor some values of $n$, you might notice that the output includes every number from 1 to $n - 1$. What is true about all the values of $n$ for which this happens?","pos":77,"type":"cell"}
{"cell_type":"markdown","id":"69c916","input":"The code for performing affine encryption below looks very, very similar to the `shift_encrypt_letter` function we developed in the last module.","pos":31,"type":"cell"}
{"cell_type":"markdown","id":"6a2749","input":"*****","pos":54,"type":"cell"}
{"cell_type":"markdown","id":"6bc2e7","input":"<span style='color:#9c27b0'>_Please write up your answer here?_</span>\n","pos":72,"type":"cell"}
{"cell_type":"markdown","id":"78f19d","input":"Testing the function:","pos":67,"type":"cell"}
{"cell_type":"markdown","id":"7b77b6","input":"And now we have access to the `gcd` function, as illustrated below:","pos":57,"type":"cell"}
{"cell_type":"markdown","id":"7cc0d6","input":"### Exercise 11\n\nTest the new function `affine_encrypt` by trying to use an illegal value of $m$.","pos":63,"type":"cell"}
{"cell_type":"markdown","id":"7efc99","input":"The multiplicative inverse of 2 using normal real numbers is, indeed, 1/2.\n\nIf we want to do the problem in modular arithmetic, we can throw in the modulus as a third argument to the function:","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"859608","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"87a9f5","input":"### Exercise 3\n\nVerify that 3 and 9 are inverses mod 26 by multiplying them together and reducing mod 26.","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"8821ae","input":"### Exercise 6\n\nThere are only two lines of code that changed from the `shift_encrypt_letter` function. Which lines are they, and what were the changes? (You are welcome to go back and look at the `shift_encrypt_letter` function in the previous assignment, but I'll bet you can spot the differences without having to.)","pos":33,"type":"cell"}
{"cell_type":"markdown","id":"921378","input":"Now we need to extend the single letter encryption function to one that will encrypt an entire message. We do this with a for loop.","pos":43,"type":"cell"}
{"cell_type":"markdown","id":"9443f8","input":"### Exercise 10\n\nThe new line of code\n\n```\nif math.gcd(m, 26) != 1:\n```\n\ncontains a symbol we have not seen before: `!=`.\n\nGiven what you know about the purpose of this line of code, what is the meaning of `!=`?","pos":61,"type":"cell"}
{"cell_type":"markdown","id":"a0a0c3","input":"Let's try it with some plaintext: \"Affine ciphers aren't so bad!\" Suppose the key is 21 and $m = 15$.","pos":45,"type":"cell"}
{"cell_type":"markdown","id":"a595fa","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"a79adf","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":84,"type":"cell"}
{"cell_type":"markdown","id":"a7e1d0","input":"Let's test this function with some letters that we can verify by hand. For example \"c\" = 2. Let's suppose that the key is 16 and $m = 3$.\n\n$$\n3(2) + 16 = 22\n$$\n\nThe letter corresponding to 22 is \"W\".","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"a938a4","input":"## Decryption\n\nYou may recall from the last module that we were able to use the shift encryption function in a clever way to produce a decryption function with almost no additional fuss. The idea was that decryption was equivalent to encryption, but with a negative key.\n\nHowever, for affine ciphers, the decryption formula is not just a simple modification of the encryption formula. Recall that encryption looks like\n\n$$\nc_i \\equiv m p_i + k \\mod 26\n$$\n\nwhereas decryption looks like\n\n$$\np_i \\equiv m^{-1} (c_i  - k) \\mod 26\n$$\n\nBut not all is lost. If we continue to manipulate the above congruence by distributing $m^{-1}$, we get\n\n$$\np_i \\equiv m^{-1} c_i  - m^{-1} k \\mod 26\n$$\n\nIn other words, if we start with a ciphertext letter, we first have to multiply it by $m^{-1}$. But then all we have to do is shift by $-m^{-1}k$. In other words, we can use the encryption algorithm with key $-m^{-1}k$. Let's try it:","pos":65,"type":"cell"}
{"cell_type":"markdown","id":"a96869","input":"*****","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"b4c7e0","input":"The answer is 9.","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"b64547","input":"\n*****","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"b69184","input":"If we want to calculate inverses, we can use a -1 for the power:","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"b6ab22","input":"### Exercise 12\n\nIn the case of a shift cipher, there are only 25 different possible keys. How many possibilities are there for an affine cipher once we include the choice of $m$? (Assume that $m = 1$ is a valid choice.)","pos":71,"type":"cell"}
{"cell_type":"markdown","id":"b73a16","input":"## Encryption\n\nWe can now write a function that will encrypt a message using an affine cipher. Before we do so, though, we need to re-introduce the little helper functions from the last module that converted letters to numbers and numbers to letters.\n\nThe following code cell contains no new code. It's just a copy of two functions we developed in the last module. You should be hitting Ctrl-Enter in every code cell, but be extra sure to do so below. If you don't, there are code cells later that will not work.","pos":29,"type":"cell"}
{"cell_type":"markdown","id":"b8fd00","input":"It works!","pos":38,"type":"cell"}
{"cell_type":"markdown","id":"c19393","input":"## Conclusion\n\nAffine ciphers add enough complexity that it would be very difficult to decrypt them by hand. Even a brute force algorithm to do so starts straining our resources a bit. It doesn't actually strain the computer at all; the program runs in mere hundredths of a second! But it is starting to strain our ability to look through that much output to try to spot the plaintext.","pos":85,"type":"cell"}
{"cell_type":"markdown","id":"c2070c","input":"The `pow` function is actually a function to calculate powers of a number. For example, $2^{4}$ is 16.","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"c67299","input":"For the next part, we'll need a list of the numbers that are relatively prime to 26. (Such numbers are called \"units\" mod 26.) We could input such a list manually, but let's use the magic of computer programming to accomplish the task instead. The code below works for any integer $n$ (not just 26).\n\nA few things to note about the code below.\n\n* The first line of code defines the function with name `generate_units` and takes, as input, an integer $n$. That value $n$ is the modulus. (It will be 26 for applications we care about.)\n* The next line initializes an empty \"list\" using brackets `[]`. We will populate this list one element at a time in the subsequent code.\n* The next line is a for loop that loops through all integers $m$ from 1 up to $n - 1$.\n* The if statement checks if each $m$, in turn, is relatively prime to the modulus $n$. The new thing to notice here is the double equal sign `==`. In code, we use a single equal sign to assign values to variables. If we want to *test* that two things are equal, we have to use a double equal sign.\n* If we have a unit (a number relatively prime to $n$), we will `append` it to the list, meaning, we will tack it onto the end of the list already generated.\n* Note that if the for loop hits a value of $m$ that is *not* relatively prime to $n$, the statement inside the `if` clause just gets skipped and nothing happens.\n* When the for loop is finished, the last line of code returns the completed list to the user.","pos":74,"type":"cell"}
{"cell_type":"markdown","id":"c7a34d","input":"### Exercise 5\n\nWhat happens if you try to find an inverse that doesn't exist? Try it in the code cell below. (Hint: First you need to find a number that has no inverse for a certain modulus. When is it the case that a number fails to have an inverse?)","pos":25,"type":"cell"}
{"cell_type":"markdown","id":"cb5b8e","input":"*****","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"cbdf66","input":"### Exercise 1\n\nThe formula above converts plaintext numbers $p_i$ to ciphertext numbers $c_i$ by adding the key $k$ and reducing the result mod 26. (The numbers, of course, represent letters.)\n\nMake a few small changes to the formula above to show what happens when you decode the ciphertext numbers to produce plaintext numbers. In other words, rewrite the linear congruence by solving for $p_i$.\n\nHere is the formula copied from above. <span style='color:#9c27b0'>Make the changes below</span>:\n","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"cf46c3","input":"<span style='color:#9c27b0'>_Please write up answer here._</span>\n","pos":62,"type":"cell"}
{"cell_type":"markdown","id":"cfee17","input":"### Exercise 15\n\nTest out your function on the ciphertext\n\n\"NS'B DJPW WHKGXK SL ONUG SWX CMHNUSXIS RWXU ZLJ WHAX SL BPKLMM SWKLJFW BL DHUZ CLBBNYNMNSNXB!\"\n\nIf you did everything correctly above, the output should be 300 lines (!), 299 of which will be complete and utter nonsense, and one of which will be the plaintext. In the space below the code cell (keep scrolling!), write out the plaintext with proper spacing and punctuation. Also indicate what key and what value of $m$ was used to encrypt the message.\n","pos":82,"type":"cell"}
{"cell_type":"markdown","id":"d6f39f","input":"<span style='color:#673ab7'>_Please write up your answer here._</span>\n\n","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"d9de46","input":"### Exercise 9\n\nTry encrypting any phrase you'd like using any key and $m = 13$. (Test it with several different choices of key.) Explain using modular arithmetic the weird output you get.","pos":51,"type":"cell"}
{"cell_type":"markdown","id":"de564d","input":"The *affine cipher* is a generalization of the shift cipher, where you multiply by a number first before shifting:\n\n$$\nc_i \\equiv m p_i + k \\mod 26\n$$\n\nThis is much harder to decode. In a simple shift cipher, once you have one letter correct, the key becomes apparent and the rest of the message is trivial to decipher. With the affine cipher, not only is the key $k$ unknown, but also the multiplicative factor $m$.\n\nTo decrypt a message encoded with an affine cipher, we have to solve the above linear congruence for $p_i$. The first step of subtracting $k$ from both sides is straightforward:\n\n$$\nm p_i \\equiv c_i  - k \\mod 26\n$$\n\nThere is no way to \"divide by $m$\" in a linear congruence, but we may be able to find the multiplicative inverse of $m$. If such an inverse $m^{-1}$ exists, we can multiply both sides by it to isolate $p_i$:\n\n$$\np_i \\equiv m^{-1} (c_i  - k) \\mod 26\n$$\n\n\n\n","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"e078b3","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":79,"type":"cell"}
{"cell_type":"markdown","id":"e103d2","input":"$$\nc_i \\equiv p_i + k \\mod 26\n$$\n\n","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"e7e598","input":"*****","pos":35,"type":"cell"}
{"cell_type":"markdown","id":"eeb137","input":"<span style='color:#9c27b0'>_Please write up your answer here._</span>\n","pos":50,"type":"cell"}
{"cell_type":"markdown","id":"f524e0","input":"Woo hoo!","pos":69,"type":"cell"}
{"cell_type":"markdown","id":"f6de20","input":"Notice that nothing in our function prevents us from using a \"forbidden\" value of $m$. Let's see what happens when we do.\n\nFor example, $m = 2$ is not relatively prime to 26. So what happens if we use $m = 2$? To make it even easier to see the problem, let's set our key to 0. In other words, after multiplying by 2, there will be no additional shift.","pos":47,"type":"cell"}
{"id":0,"time":1709845970069,"type":"user"}
{"last_load":1707331216978,"type":"file"}